# 设计模式  

## 简单工厂  
在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。  
简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。  
这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。  
**应用场景**：对于产品种类相对较少的情况，考虑使用简单工厂模式。  

把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。
如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，创建实例的方法通常为静态方法  
简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。  

## 工厂方法  

> 工厂模式：“创建与使用相分离”的特点   

定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。  
在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。  


优点：  
1. 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。  
2. 灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。  
3. 典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。  

缺点：  
1. 类的个数容易过多，增加复杂度  
2. 增加了系统的抽象性和理解难度  
3. 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。  

应用场景：  
1. 客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。  
2. 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。  
3. 客户不关心创建产品的细节，只关心产品的品牌  


工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。   
1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。  
2. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。  
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。  
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。  


## 抽象工厂  
提供一个接口，用于创建**相关的对象家族**。  
抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。  

使用抽象工厂模式一般要满足以下条件：   
1. 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。  
2. 系统一次只可能消费其中某一族产品，即同族的产品一起使用。  

抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下：  
1. 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。  
2. 当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品组。  
3. 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。  

其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。  

抽象工厂模式通常适用于以下场景：  
当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。  
系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。  
系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。  

















