# 2021/07/26

## 2021/07/22面经知识点整理2  

- 线程会共享什么资源，**JMM是什么**    
线程共享的资源有**堆、全局变量、静态变量、文件等公共资源**  
JMM指**Java内存模型**  
内存模型描述了程序中各个变量（实例域、静态域和数组元素）之间的关系，以及在实际计算机系统中将变量存储到内存和从内存中取出变量这样的底层细节。  
JMM设计系统存在一个主内存，Java中所有实例变量都存储在主存中，对于所有线程都是共享的。
每个线程都有自己的工作内存，由缓存和堆栈两部分组成，缓存保存的是主存中变量的拷贝，堆栈中保存的是线程的局部变量。  
Java内存模型，围绕着在并发过程中如何处理**原子性、可见性、有序性**这三个特性而建立的模型。  
原子性：指一个操作是不可中断的  
可见性：指在多线程情况下，当一个线程修改了某一个共享变量的值之后，其他线程是否能够立即知道这个修改  
有序性：由于编译器优化进行了指令重排操作，保证指令重排不会使串行的语义逻辑发生问题   

- 乐观锁悲观锁——数据库，java多线程里面也有？？   
悲观锁：悲观并发控制，指对数据被外界修改持保守态度，借助数据库锁机制，在修改数据之前先锁定再修改。**写多读少**  
悲观锁的实现：1.传统的关系型数据库使用锁机制，如行锁，表锁，读锁，写锁；2.Java里面的同步synchronized关键字的实现  
悲观锁主要分为共享锁（读锁，S锁）和排他锁（写锁，X锁）  
乐观锁：在数据进行提交更新的时候，才会正式对数据的冲突进行检测。**读多写少**  
乐观锁的实现：1.CAS（比较并交换） 2.版本号控制  

- linkedlist和arraylist区别，内存分配上   
底层数据结构：Arraylist底层使用的是Object数组，Linkedlist底层使用的是双向链表   
插入和删除是否受元素位置的影响   
是否支持快速随机访问  
内存空间占用：Arraylist的空间浪费主要体现在list列表的结尾会预留一定的容量空间，Linkedlist的空间花费体现在它每一个元素都需要消耗比Arraylist更多的空间。  

- 接口和抽象类  
**设计层次**：接口只提供一种方法实现契约，LIKE-A关系；抽象类即子类对象必须能够替换掉所有父类对象，IS-A；  
**使用**：一个类可以实现多个接口，不能继承多个抽象类；  
接口字段只能是static和final类型的，而抽象类的字段没有这种限制；  
接口成员只能是public，而抽象类的成员可以有多种访问权限；  


- 阻塞IO和非阻塞IO  
**阻塞IO**：在IO执行的两个阶段都被block了  
**非阻塞IO**：用户进程不断的主动询问kernel数据准备好了没有  


- java有内存泄漏吗  
内存泄露：JVM误以为此对象还在引用中，无法回收    
1. 静态集合类，HashMap、Linkedlist等，长生命周期的对象持有短生命周期对象的引用  
2. 各种连接，数据库连接、网络连接、IO连接等  
3. 变量不合理的作用域，变量定义的作用范围大于适用范围   
4. 内部类持有外部类  
5. 改变哈希值  
6. **缓存**泄露  
7. 监听器和回调  
8. **类加载器**  
9. **全局变量**  

- java有没有内存溢出  

- 类加载机制和双亲委派  
类加载过程：加载->连接->初始化，连接分为：验证->准备->解析  
双亲委派模型，即在类加载的时候，系统会首先判断当前类是否被加载过，已经被加载的类会直接返回，否则才会尝试加载。  

- BIO和NIO区别  == 阻塞IO和非阻塞IO


- IP是可靠的吗，TCP如何保证可靠  
IP协议是不可靠无连接的。  
因为每个IP数据报都是独立寻址的，就是说每个IP数据报都是一个独立的实体，不需要维护后续分组相关的状态信息。  
TCP使用**超时重传**来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

- JUC包，提到线程池和synchronized，线程池常用哪些参数（什么是JUC包）  
JUC，java.util.concurrent包，是JDK提供的一个处理并发的工具包，包括线程池、异步IO和轻量级任务框架，还提供了用于多线程上下文中的Collection实现等。  
1. **atomic**包，里面存放的是支持原子操作的、处理基本数据类型的类，该包下大量使用到了CAS技术。（核心是CAS，主要提供了一系列原子变量更新操作的类，提供非阻塞式算法基础）    
2. **locks**包，里面存放的是实现处理并发的类，该包大量使用到AQS技术。（主要提供了显示锁，如重入锁ReentrantLock和读写锁，核心是AQS这个抽象队列同步器框架）  
3. 并发容器  
4. 执行框架与线程池  
5. 并发工具类  

**线程池**  
为什么要使用线程池？    
1. 创建/销毁线程需要消耗资源，线程池可以复用已创建的线程  
2. **控制并发的数量**。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。  
3. **可以对线程做统一管理**    

JUC下线程池的体系结构  

![image](https://user-images.githubusercontent.com/87803098/127143968-596c9718-e7b3-4a39-9dc7-79b17d19de5f.png)  

创建线程池的两种办法  
1. 使用ThreadPoolExecutor的构造方法创建  
2. 使用Executors这个工具类来实现  
JDK工具类提供了四种常用的线程池，其实它们的底层源码都是调用ThreadPoolExecutor来实现的，传递的线程池参数不同罢了。  
#### 线程池ThreadPoolExecutor的七大参数  
1. corePoolSize：核心线程的最大值，相当于正式员工，到点才下班  
2. maximumPoolSize：核心线程+非核心线程的最大值，非核心线程相当于临时工，核心线程处理不过来才会激活非核心线程，业务量低时先下班  
3. keepAliveTime：非核心线程闲置超时时长，超时了非核心线程被销毁  
4. TimeUnit unit：keepAlive Time的时间单位  
5. workQueue：阻塞队列，线程池的底层也用了阻塞队列，维护等待执行的线程对象  
6. ThreadFactory threadFactory：创建线程的工程，一般使用Excetory的默认实现默认实现  
7. RejectedExecutionHandler handler：阻塞队列满了之后对新来线程的拒绝策略，默认有四种：  
ThreadPoolExecutor.AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。  
ThreadPoolExecutor.DiscardPolicy：丢弃新来的任务，但是不抛出异常。  
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。  
ThreadPoolExecutor.CallerRunsPolicy：返回给上一步，由调用线程处理该任务。  
#### 线程池调度的策略：  
线程池调度的核心是execute方法，执行execute方法和submit方法有何区别？  
execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；  
submit()方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的get()方法来获取返回值。  
这也可以看到线程池的又一优点：灵活。  
![image](https://user-images.githubusercontent.com/87803098/127145445-d6e9bad8-e85a-4104-bec4-897624eb5793.png)


![image](https://user-images.githubusercontent.com/87803098/127113490-ca00a400-0cfc-4b4c-9e3f-55fbce9b2e21.png)


- core满了以后会怎么，如果没有设置core，不断的有请求，会发生什么（什么是core）  
**core满了以后**：新来的请求会进入阻塞队列。  
**如果没有设置core，不断的有请求，会发生什么**：线程池里面的参数都是有默认值的（不设置的时候）,当有不断的请求时，会先将core不能及时处理的线程放入任务队列里面，当任务队列满时，且当前线程数小于最大线程数时，线程池会创建新的线程来处理。当请求线程大于最大线程数时，线程池会拒绝处理并抛出异常.    
> 默认值  
>   
> corePoolSize=1  
> queueCapacity=Integer.MAX_VALUE  
> maxPoolSize=Integer.MAX_VALUE  
> keepAliveTime=60s  
> allowCoreThreadTimeout=false  
> rejectedExecutionHandler=AbortPolicy()  


- 主键索引和二级索引的区别和联系  
**主键索引**
数据表的主键列使用的就是主键索引。  
一张数据表有只能有一个主键，并且主键不能为 null，不能重复。 
**二级索引(辅助索引)**  
二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。  
唯一索引，普通索引，前缀索引等索引属于二级索引。  
二级索引属于非聚集索引。  

- 死锁的四个条件（*下面正好同学今天也问到了*）  
互斥：每个资源要么已经分配给了一个进程，要么就是可用的。  
占有和等待：已经得到了某个资源的进程可以再请求新的资源。  
不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。  
环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源  


- redis如何持久化  


- http和https区别，https头部有哪些信息  （*问到的概率都很大*）   
https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。  
http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。  
http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。  
http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。  
 



- arraylist如何扩容
添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity >> 1)，即 oldCapacity+oldCapacity/2。其中 oldCapacity >> 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）   
扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。   

- 静态变量在哪个部分存
JDK1.6：在方法区
JDK1.8：本地内存的元空间

- set底层实现
HashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素  
LinkedHashSet：LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的  
TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树)  

