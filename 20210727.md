# 2021/07/27

## 2021/07/27 同学字节抖音海外客户端上海一面  

- java多线程同步的方式？
  1. 同步方法  
    用synchronized关键字修饰方法。 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。  
  2. 同步代码块  
    用synchronized关键字修饰语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步  
  3. 使用特殊变量volatile实现线程同步  
    a.volatile关键字为域变量的访问提供了一种免锁机制  
    b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新  
    c.因此每次使用该域就要重新计算，而不是使用寄存器中的值  
    d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量  
  4. 使用重入锁实现线程同步  
    在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。  
    ReenreantLock类的常用方法有：  
    ReentrantLock() : 创建一个ReentrantLock实例  
    lock() : 获得锁  
    unlock() : 释放锁  
  5. 使用局部变量实现线程同步  
    如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。  
    ThreadLocal 类的常用方法  
    ThreadLocal() : 创建一个线程本地变量  
    get() : 返回此线程局部变量的当前线程副本中的值  
    initialValue() : 返回此线程局部变量的当前线程的"初始值"  
    set(T value) : 将此线程局部变量的当前线程副本中的值设置为value  
    
- 死锁发生的原因，举例
  互斥：每个资源要么已经分配给了一个进程，要么就是可用的。  
  占有和等待：已经得到了某个资源的进程可以再请求新的资源。  
  不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。  
  环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。  

- HashMap线程不安全，ConcurrentHashMap如何保证的线程安全，里面的分段锁是如何加的，怎么分段的
   ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。  
    Segment 继承自 ReentrantLock。

- java 静态链接和动态链接
  **静态绑定**在程序执行前方法已经被绑定，java当中的方法只有final、static、private和构造方法属于静态绑定  
  **动态绑定**在运行时根据具体对象的类型进行绑定   
  解析调用一定是个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成，这也就是Java中的静态链接。  
  在运行期间转化为直接引用，就称为动态链接。  

- 操作系统里的物理地址和虚拟地址
**物理地址**：用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。物理地址是内存单元真正的地址。    
**虚拟地址**：每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间，虚拟地址由操作系统决定。  

- UDP和TCP的区别，适用场景
    用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。  
    传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。  
    TCP和UDP适用场景
    从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。  
    若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。  
    
- 有了TCP，为什么还有UDP，UDP的优势或适用情况  
    通信数据完整性与通信实时性的矛盾  

- TCP四次挥手中，中间两次为什么不能合二为一


- TCP进行拥塞控制的算法
    TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。  
    发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。  
    为了便于讨论，做如下假设：  
    接收方有足够大的接收缓存，因此不会发生流量控制；  
    虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。  
    1. 慢开始与拥塞避免  
    发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...  
    注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。  
    如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。  
    2. 快重传与快恢复  
    在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。  
    在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。  
    在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。  
    慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。  

- Https加密方式  
    使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;  
    获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）  

- final关键字介绍
    final 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：  
    final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；  
    final 修饰的方法不能被重写；  
    final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。  

- 怎么写内部类和外部类，定义内部类的时候加不加static，加和不加的区别，内部类有没有对外部实例的引用
  内部类：就是在一个类中定义一个类。  
  内部类的访问特定  
  1. 内部类可以直接访问外部类的成员，包括私有，但外部类不可以直接访问内部类的元素  
  2. 外部类只能访问内部类的静态常量，要访问内部类的成员，必须创建对象  
  按照内部类在类中定义的位置不同，分为成员内部类，局部内部类  
  匿名内部类属于局部内部类的一种特殊形式，new开头，本质是**一个继承了该类或实现了该接口的子类匿名对象**  
  静态内部类，用static修饰：  
  非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类，静态内部类则没有。  
  意味着：静态内部类的创建不需要依赖外部类，可以直接创建；静态内部类不可以使用任何外部类的非static成员变量和方法，而内部类都可以  
  
- 双亲委派模式，类加载机制


- 引用模式：强引用，软引用，弱引用，虚引用
  1. 强引用  
  被强引用关联的对象不会被回收。  
  使用 new 一个新对象的方式来创建强引用。  
  2. 软引用  
  被软引用关联的对象只有在内存不够的情况下才会被回收。  
  使用 SoftReference 类来创建软引用。  
  3. 弱引用  
  被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。  
  使用 WeakReference 类来创建弱引用。  
  4. 虚引用  
  又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。  
  为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。  
  使用 PhantomReference 来创建虚引用。  

- 堆排复杂度，为什么？  

![image](https://user-images.githubusercontent.com/87803098/127166803-9434a1d8-b5eb-4b0f-a1fb-796c103bcad8.png)  


- 设计模式：单例模式是什么，多线程情况下？


- 手撕代码：重建二叉树


- 有没有想问的

## 另一个同学的（同一位面试官）

- 线程池


- 垃圾回收


- 缺页中断  
  页面置换算法：  
  1. 最佳  
  2. 最近最久未使用  
  3. 最近未使用  
  4. 先进先出  
  5. 第二次机会算法  
  6. 时钟  


- threadlocal的主要参数
