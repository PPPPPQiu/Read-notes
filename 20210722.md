# 2021/07/22

## JAVA基础
### 异常处理
- try用来指定一块预防所有异常的类型  
- catch用来指定你想要捕获的异常的类型  
- throw用来明确抛出一个异常  
- throws用来声明一个可能抛出的各种异常  
- finally用来确保一段代码不管发生什么异常状况都执行 

### 上下文切换：任务从保存到加载  
#### 如何减少上下文切换  
1. 避免锁使用  
2. CAS算法  
3. 避免创建线程  
4. 协程  



## 同学今天字节一面  

这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当 收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都 全部发送给对方了，所以你可以未必会马上会关闭 SOCKET,也即你可能还需要发送一些数据 给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。  

  
  
HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。  

**HTTPS和HTTP的区别主要如下：**  
1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。  
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。  
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。  
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。    


**堆排序**  
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。  
  
  
**归并排序**  
归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。  
  
>**选择排序、快速排序、希尔排序、堆排序**是**不稳定**的排序算法，而**冒泡排序、插入排序、归并排序和基数排序**是**稳定**的排序算法。  

#### 数组和链表的优缺点：  
数组的优点：  
1.随机访问性强  
2.查找速度快  

数组的缺点:  
1.插入和删除效率低  
2.可能浪费内存  
3.内存空间要求高， 必须有足够的连续内存空间  
4.数组大小固定， 不能动态拓展  
  
链表的优点:  
1.插入删除速度快  
2.内存利用率高， 不会浪费内存   
3.大小没有固定， 拓展很灵活   
  
链表的缺点:  
不能随机查找，必须从第一个开始遍历，查找效率低  
  
**时间复杂度：**     
数组：  
查找：O(1)  
插入：最好情况，在表尾插入 O(1)；最坏情况，在表头插入 O(n);平均情况 O(n)(n/2 就是 n)  
删除：最好情况，在表尾删除 O(1)；最坏情况，在表头删除 O(n);平均情况 O(n)(n/2 就是 n)  
元素需要移动  
链表：  
查找：O(n)  
插入：O(1)  
删除：O(1)  


基本概念：进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；  
线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。  

区别：  
1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。  
2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）  
3.进程是资源分配的最小单位，线程是CPU调度的最小单位；  
4.系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。  
5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预  
6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。  
7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉  
8.进程适应于多核、多机分布；线程适用于多核  

  
死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。  
**死锁发生的四个必要条件如下：**  
互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；  
请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源  
不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放  
环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链  
  
解决死锁的方法即破坏上述四个条件之一，主要方法如下：  
资源一次性分配，从而剥夺请求和保持条件  
可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件  
资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件  
  
  **互斥锁**：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败 时，线程会进入睡眠，等待锁释放时被唤醒。
  **读写锁**：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但 是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写 锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能 被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。 适用于读取数据的频率远远大于写数据的频率的场合。
