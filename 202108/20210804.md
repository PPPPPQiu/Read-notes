# 知识点再复习  

## Java基础  

### 数据类型  
- byte/8  
- char/16  
- short/16  
- int/32  
- float/32  
- long/64  
- double/64  
- boolean/~  

### String, StringBuffer and StringBuilder
1. 可变性  
- String 不可变  
- StringBuffer 和 StringBuilder 可变  
2. 线程安全  
- String 不可变，因此是线程安全的  
- StringBuilder 不是线程安全的  
- StringBuffer 是线程安全的，内部使用 synchronized 进行同步  

### 关键字  
#### final  

#### static  
1. 静态变量
2. 静态方法：在类加载的时候就存在  
3. 静态语句块：在类初始化时运行一次  
4. 静态内部类：不需要先创建外部类实例   


##### 初始化顺序  
父类-静态变量、静态语句块  
子类-静态变量、静态语句块  
父类-实例变量、普通语句块  
父类=构造函数  
子类-实例变量、普通语句块  
子类-构造函数  


### Object通用方法  

#### equals()  
1. 等价关系  
自反性、对称性、传递性、一致性、与null的比较   

#### clone()  
浅拷贝：拷贝对象与原始对象的引用类型引用同一个对象  
深拷贝：拷贝对象和原始对象的应用类型引用不同对象  


### 继承  

#### 抽象类与接口  

##### 比较  
- 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。  
- 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。   
- 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。    
- 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。  

##### 使用选择  

#### super  

#### 重写与重载  

##### 重写  
在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。  
方法调用的优先级为：  
- this.func(this)  
- super.func(this)  
- this.func(super)  
- super.func(super)  

### 反射  
反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。  

### 异常  

### 泛型  

## Java容器  

### Collection  

#### Set  
TreeSet:红黑树  
HashSet：哈希表  
LinkedHashSet：内部使用双向链表维护元素的插入顺序  

#### List  
ArrayList：动态数组  
Vector：线程安全  
LinkedList：双向链表  

#### Queue  
LinkedList：双向队列  
PriorityQueue：基于堆结构，优先队列  

### Map  
TreeMap：红黑树  
HashMap：哈希表  
ConcurrentHashMap：线程安全  
HashTable：线程安全  
LinkedHashMap：双向链表

### 源码分析  

#### ArrayList  
##### 扩容  
使用grow()方法进行扩容，新容量oldCapacity+oldCapacity/2，1.5倍  

> 不被序列化：**transient**  

##### 替换方案  
1. 使用Collections.synchronizedList();得到一个线程安全的ArrayList  
2. 使用concurrent并发包下的CopyOnWriteArrayList类  


##### CopyOnWriteArrayList  
1. 读写分离  
写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。  
写操作需要加锁，防止并发写入时导致写入数据丢失。  
写操作结束之后需要把原始数组指向新的复制数组。   

适合**读多写少**的应用场景  
2. 缺陷    
- 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；  
- 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中    
不适合内存敏感以及对实时性要求很高的场景  
  
#### Vector  
使用了synchronized进行同步  

##### 扩容  
传入参数capacityIncrement，扩容每次增长capacityIncrement，默认翻倍   

  
  
#### LinkedList  
  双向链表，使用Node存储链表节点信息，每个链表存储了first和last指针  
  1. 与ArrayList的比较：数组和链表的比较  
  
  #### HashMap  
  （需要详细介绍）  
  
  #### ConcurrentHashMap  
  采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶  
  ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。  
  如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。  
  
  
  #### LinkedHashMap  
  内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。  
  
  #### WeakHashMap  
  WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。  
  WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。  
  Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。  
  ConcurrentCache 采取的是分代缓存  
  
## Java并发  

### 使用线程  
1. 实现Runnable接口  
2. 实现Callable接口  
3. 继承Thread类  

### 基础线程机制  
1. Executor  
2. Daemon  
3. sleep()
4. yield()  

### 中断  
1. InterruptedException  
2. interrupted()  
3. Executor的中断操作  

### 互斥同步  
控制多个线程对共享资源的互斥访问  
1. JVM实现的synchronized
  - 同步一个代码块  
    只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步  
  - 同步一个方法  
  - 同步一个类
    作用于整个类，两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步  
    
  - 同步一个静态方法



2. JDK实现的ReentrantLock  
3. 比较  
  - 锁的实现  
  - 性能  
  - 等待可中断  
  - 公平锁  
  - 锁绑定多个条件  

4. 使用选择  

### 线程之间的协作  

### 线程状态  
新建、可运行、阻塞、无限期等待、限期等待、死亡  

### Java内存模型  

#### 主内存和工作内存  
每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。  
线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。  

#### 内存模型三大特性：原子性、可见性、有序性  

#### 先行发生原则  
  1. 单一线程原则  
  2. 管程锁定规则  
  3. volatile变量规则  
  4. 线程启动规则  
  5. 线程加入规则  
  6. 线程中断规则  
  7. 对象终结规则  
  8. 传递性

### 线程安全  
1. 不可变  
2. 互斥同步
3. 非阻塞同步（CAS、AtomicInteger、ABA）  
4. 无同步方案（栈封闭、线程本地存储、可重入代码）  

### 锁优化  
指JVM对synchronized的优化  
#### 自旋锁  
自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环(自旋)一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态  
适用于共享数据的锁定状态很短的场景  

#### 锁消除  
锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除  
锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。  

#### 锁粗化  

#### 轻量级锁  
JDK1.6锁拥有四个状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态  
轻量级锁使用CAS操作来避免重量级锁使用互斥量的开销  

#### 偏向锁  
偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作。  
当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向后恢复到未锁定状态或轻量级锁状态。  




## Java虚拟机  

## Java I/O  
