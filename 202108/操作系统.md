
# 进程  

## 进程和线程的区别  
- 进程是资源分配的基本单位，线程是程序运行的基本单位  
- 一个线程属于一个进程，一个进程可以有多个线程  
- 进程在执行时有独立的内存单元，而多个线程共享进程的内存  
- 通信：进程间通信需要IPC，同一进程间的线程通信可以直接读取进程代码段  
- 系统开销：进程大，线程小  

# 内存管理  
## 虚拟内存  
一方面保护了操作系统的安全，另一方面允许应用程序使用比实际物理内存更大的地址空间。  

## 虚拟内存到物理内存的映射  
虚拟内存到物理内存的映射由操作系统动态维护。  
### 分页系统地址映射  
内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。





### 分段  
分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。




### 分页与分段的比较
对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。

地址空间的维度：分页是一维地址空间，分段是二维的。

大小是否可以改变：页的大小不可变，段的大小可以动态改变。

出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。




## 锁  
### 读写锁  
- 多个读者可以同时进行读  
- 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）  
- 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）  


### 互斥锁  
一次只能一个线程拥有互斥锁，其他线程只有等待  
互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒  
互斥锁在加锁操作时涉及上下文的切换  

### 条件变量  
条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足  
互斥锁是线程间互斥的机制，条件变量则是同步机制。  

### 自旋锁  
如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。  

# 死锁  

互斥条件：该资源任意一个时刻只由一个线程占用。  
占有和等待条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  
不可抢占条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。  
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。  



# 生产者和消费者  
```  
int empty = N;
int full = 0;
int mutex = 1;
```  
## 生产者  
```
down(empty);
down(mutex);
生产;
up(mutex);
up(full);
```


## 消费者  
```
down(full);
down(mutex);
消费;
up(mutex);
up(empty);
```





