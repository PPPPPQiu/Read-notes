
# 树  
## B树  
## B+树  
## 红黑树  
二叉查找树（二叉搜索树）：左子树节点小于等于根节点，右子树节点大于等于根节点，左右子树也是二分查找树。  
缺点：极端情况下接近线性查找。  
红黑树是一个棵自平衡的二叉查找树，五条重要的性质：  
每个节点要么是黑色，要么是红色  
根节点是黑色  
每个叶子节点（NIL）都是黑色  
每个红色节点的两个子节点都一定是黑色（从叶子到根的所有路径不能存在连续的红节点）  
任意一节点到叶子节到每个叶子节点的路径都包含数量相同的黑色节点  


## Hash

# MySQL  
关系型数据库  


### 数据库三大范式  
第一范式：每个列都不可以再拆分。  
第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。  
第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。  

### MySQL存储引擎  
**Innodb引擎**：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。  
**MyIASM引擎**：不提供事务的支持，也不支持行级锁和外键。  
**MEMORY引擎**：所有的数据都在内存中，数据的处理速度快，但是安全性不高。  

MyISAM索引与InnoDB索引的区别？  
- InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。  
- InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。  
- MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。  
- InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。  

比较
事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。  
并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。  
外键：InnoDB 支持外键。  
备份：InnoDB 支持在线热备份。  
崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。  
其它特性：MyISAM 支持压缩表和空间数据索引。  
![UBP$)GIF%C446P3F46FVB%8](https://user-images.githubusercontent.com/87803098/130386469-1ef5f154-2fad-4956-8c81-1c28eba22943.png)



### 什么是索引  
索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。  
优点：  
可以大大加快数据的检索速度。  
通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。  
缺点：  
时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；  
空间方面：索引需要占物理空间。  

索引的使用场景：where，order by，join，索引覆盖  
索引覆盖，如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据  

#### 索引有哪几种类型  
主键索引：数据列不允许重复，不允许为NULL，一个表只能有一个主键。  
唯一索引：数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。  
普通索引：基本的索引类型，没有唯一性的限制，允许为NULL值。  
全文索引：是目前搜索引擎使用的一种关键技术。  


#### 索引的数据结构  
B+树索引（默认）  
在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。  
B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。  

哈希索引  
在绝大多数需求为单条记录查询的时候，可以选择哈希索引

- 为什么使用B+树  
B树只适合随机检索，而B+树同时支持随机检索和顺序检索；  
B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。  
B+树的查询效率更加稳定。  
B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。
增删文件（节点）时，效率更高。  

聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据  
非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行  


### 事务  
事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。  

原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；  
一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；  
隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；  
持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  

丢失修改，读脏数据，不可重复读，幻读  
未提交读，提交读，可重复读，可串行化   

事务隔离机制的实现基于锁机制和并发调度。  
按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎)。  

行级锁，为共享锁和排他锁。   
特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  

表级锁，分为表共享读锁（共享锁）与表独占写锁（排他锁）。  
特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。  

页级锁   
特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般  

InnoDB是基于索引来完成行锁  

#### InnoDB存储引擎的锁的算法有三种  
Record lock：单个行记录上的锁  
Gap lock：间隙锁，锁定一个范围，不包括记录本身  
Next-key lock：record+gap 锁定一个范围，包含记录本身  

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。  

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制  
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。  


### MVCC  
多版本并发控制利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。  
在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。  

#### Undo日志  
MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。  
快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。  
INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。  

#### ReadView  
MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。  
在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：  
TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。  
TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。  
TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：  
提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。  
可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。  
在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。  

#### 快照读与当前读  
快照读：MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。  
当前读：MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。  

#### Next-Key Locks  
在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。  
Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。  

- Record Locks
  锁定一个记录上的索引，而不是记录本身。  
  如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。  
- Gap Locks
  锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。  
- Next-Key Locks
  它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：  
  
  

### 视图  
视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。  
视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。  

视图使用场景：重用SQL语句，减缓复杂的SQL操作，使用表的组成部分而不是整个表，保护数据，更改数据格式和表示。  
优点：查询简单化，数据安全性，逻辑数据独立性  
缺点：性能，修改限制  

### 游标  
游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。  
用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。  

### 存储过程  
存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。  
如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。  

### 触发器  
触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。  
触发器是指一段代码，当触发某个事件时，自动执行这些代码。  












