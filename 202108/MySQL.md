
# 主键
主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。
外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。  
不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）  
不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）  
主键建议使用自增 ID 值  


# 树  
平衡二叉树的常用实现方法有 红黑树、AVL 树、替罪羊树、加权平衡树、伸展树 等  

## B树  
多路平衡查找树  
## B+树  
B 树& B+树两者有何异同  
- B 树的所有节点既存放键也存放数据，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。  
- B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。  
- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。  


## 红黑树  
二叉查找树（二叉搜索树）：左子树节点小于等于根节点，右子树节点大于等于根节点，左右子树也是二分查找树。  
缺点：极端情况下接近线性查找。  
红黑树是一个棵自平衡的二叉查找树，五条重要的性质：  
每个节点要么是黑色，要么是红色  
根节点是黑色  
每个叶子节点（NIL）都是黑色  
每个红色节点的两个子节点都一定是黑色（从叶子到根的所有路径不能存在连续的红节点）  
任意一节点到叶子节到每个叶子节点的路径都包含数量相同的黑色节点  


## Hash表

# MySQL  
关系型数据库  


### 数据库三大范式  
第一范式：每个列都不可以再拆分。  
第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。  
第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。  

### MySQL存储引擎  
**Innodb引擎**：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。  
**MyIASM引擎**：不提供事务的支持，也不支持行级锁和外键。  
**MEMORY引擎**：所有的数据都在内存中，数据的处理速度快，但是安全性不高。  

MyISAM索引与InnoDB索引的区别？  

- InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。  
- InnoDB 支持行级锁，而MyISAM 只支持表级锁。  
- InnoDB 支持外键和在线热备份，奔溃概率小恢复快。   
- MyISAM 支持压缩表和空间数据索引。  
- MyISAM适合查询以及插入为主的应用。
- InnoDB适合频繁修改以及涉及到安全性较高的应用。
![UBP$)GIF%C446P3F46FVB%8](https://user-images.githubusercontent.com/87803098/130386469-1ef5f154-2fad-4956-8c81-1c28eba22943.png)

## 索引

### 什么是索引  
索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。  
优点：  
可以大大加快数据的检索速度。  
通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。   
缺点：  
时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；  
空间方面：索引需要占物理空间。  

索引的使用场景：where，order by，join，索引覆盖  
> 索引覆盖，如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据  

### 索引有哪几种类型  
主键索引：数据表的主键列使用的就是主键索引，数据列不允许重复，不允许为NULL，一个表只能有一个主键。  
二级索引：二级索引的叶子节点存储的数据是主键，包括唯一索引、普通索引、前缀索引
> 唯一索引：唯一索引的属性列不能出现重复的数据，允许为NULL值，一个表允许多个列创建唯一索引。  
> 普通索引：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。    
> 前缀索引：只适用于字符串类型的数据，前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小。  
> 全文索引：要是为了检索大文本数据中的关键字的信息，是目前搜索引擎使用的一种关键技术。  

覆盖索引：包含了所有查询字段的索引（where、select、order by、group by）,就是把要查询出的列和索引是对应的，不做回表操作    
> 好处：避免InnoDB表进行索引的二次查询；可以把随机IO变成顺序IO加快查询效率。  

聚簇索引：引结构和数据一起存放的索引。主键索引属于聚集索引。  
> 优点：查询速度快  
> 缺点：依赖有序的数据；更新代价大； 
非聚簇索引：索引结构和数据分开存放的索引，二级索引属于非聚集索引。  
> 优点：更新代价小  
> 缺点：依赖有序数据，可能会二次查询  

### 索引的底层数据结构  

#### 哈希索引  
哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据   
解决冲突：链地址法  
在绝大多数需求为单条记录查询的时候，可以选择哈希索引
**缺点**：hash冲突；hash索引不支持顺序和范围查询  

#### B+树索引（默认）  

在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。  
B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。  

- 为什么使用B+树  
B树只适合随机检索，而B+树同时支持随机检索和顺序检索；  
B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。  
B+树的查询效率更加稳定。  
B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。
增删文件（节点）时，效率更高。  




### 事务  
事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。  

原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；  
一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；  
隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；  
持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  

丢失修改，读脏数据，不可重复读，幻读  
未提交读，提交读，可重复读，可串行化   

事务隔离机制的实现基于锁机制和并发调度。  
按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎)。  

数据库锁的类型：  
锁的粒度：行级锁、表级锁  
锁的类别：读锁、写锁  

行级锁，为共享锁和排他锁。   
特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  

表级锁，分为表共享读锁（共享锁）与表独占写锁（排他锁）。  
特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。  

页级锁   
特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般  

InnoDB是基于索引来完成行锁  

#### InnoDB存储引擎的锁的算法有三种  
Record lock：对索引项加锁    
Gap lock：间隙锁，对索引之间的“间隙”、第一条记录前的“间隙”或最后一条后的间隙加锁。    
Next-key lock：record+gap 前两种放入组合，对记录及前面的间隙加锁。  

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。  

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制  
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。  


### MVCC  
多版本并发控制利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。  
在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。  

#### Undo日志  
MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。  
快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。  
INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。  

#### ReadView  
MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。  
在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：  
TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。  
TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。  
TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：  
提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。  
可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。  
在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。  

#### 快照读与当前读  
快照读：MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。  
当前读：MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。  

#### Next-Key Locks  
在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。  
Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。  

- Record Locks
  锁定一个记录上的索引，而不是记录本身。  
  如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。  
- Gap Locks
  锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。  
- Next-Key Locks
  它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：  
  
  


## SQL语句执行  
MySQL 主要分为 Server 层和存储引擎层  
Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用  
存储引擎层 ，主要负责数据的存储和读取，redolog 只有 InnoDB 有。  

### 查询语句的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
### 更新语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log(prepare 状态)--->binlog--->redo log(commit状态)

查询语句的执行顺序：  
- from  
- join  
- on  
- where  
- group by  
- sum,avg  
- having  
- select  
- order by  
- limit  




### 视图  
视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。  
视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。  

视图使用场景：重用SQL语句，减缓复杂的SQL操作，使用表的组成部分而不是整个表，保护数据，更改数据格式和表示。  
优点：查询简单化，数据安全性，逻辑数据独立性  
缺点：性能，修改限制  

### 游标  
游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。  
用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。  

### 存储过程  
存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。  
如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。  

### 触发器  
触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。  
触发器是指一段代码，当触发某个事件时，自动执行这些代码。  




## 数据库规范  
### 数据库基本设计规范  
1. 所有表必须使用 Innodb 存储引擎  
2. 数据库和表的字符集统一使用 UTF8  
3. 所有表和字段都需要添加注释   
4. 尽量控制单表数据量的大小,建议控制在 500 万以内。  
5. 谨慎使用 MySQL 分区表  
6.尽量做到冷热数据分离,减小表的宽度   
7. 禁止在表中建立预留字段  
8. 禁止在数据库中存储图片,文件等大的二进制数据  
9. 禁止在线上做数据库压力测试  
10. 禁止从开发环境,测试环境直接连接生成环境数据库  

### 数据库 SQL 开发规范  
1. 建议使用预编译语句进行数据库操作  
2. 避免数据类型的隐式转换  
3. 充分利用表上已经存在的索引  
4. 数据库设计时，应该要对以后扩展进行考虑  
5. 程序连接不同的数据库使用不同的账号，禁止跨库查询  
6. 禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询  
7. 禁止使用不含字段列表的 INSERT 语句   
8. 避免使用子查询，可以把子查询优化为 join 操作   
9. 避免使用 JOIN 关联太多的表   
10. 减少同数据库的交互次数   
11. 对应同一列进行 or 判断时，使用 in 代替 or   
12. 禁止使用 order by rand() 进行随机排序   
13. WHERE 从句中禁止对列进行函数转换和计算   
14. 在明显不会有重复值时使用 UNION ALL 而不是 UNION   
15. 拆分复杂的大 SQL 为多个小 SQL  


### 索引设计规范  
1. 限制每张表上的索引数量,建议单张表索引不超过 5 个  
2. 禁止给表中的每一列都建立单独的索引  
3. 每个 Innodb 表必须有个主键  
4. 常见索引列建议  
5.如何选择索引列的顺序  
6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）  
7. 对于频繁的查询优先考虑使用覆盖索引  
8.索引 SET 规范  


### 数据库操作行为规范  
1. 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作   
2. 对于大表使用 pt-online-schema-change 修改表结构   
3. 禁止为程序使用的账号赋予 super 权限  
4. 对于程序连接数据库账号,遵循权限最小原则   



### 数据库字段设计规范  
1. 优先选择符合存储需要的最小的数据类型  
2. 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据  
3. 避免使用 ENUM 类型  
4. 尽可能把所有列定义为 NOT NULL  
5. 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间   
6. 同财务相关的金额类数据必须使用 decimal 类型  



> https://www.nowcoder.com/discuss/637486?source_id=profile_create_nctrack&channel=-1  
