
# 动态规划  
形式：求最值，最长递增子序列，最小编辑距离
核心问题：穷举  
组成：存在**重写子问题**，具备**最优子结构**，列出正确的**状态转移方程**  
状态转移方程：明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。  
1. 确定 base case
2. 确定「状态」，也就是原问题和子问题中会变化的变量  
3. 确定「选择」，也就是导致「状态」产生变化的行为  
4. 明确 dp 函数/数组的定义  

动态规划套路流程：  
1. 明确两点，状态和选择  
2. 明确dp数组的定义  
3. 根据选择，思考状态转移的逻辑  

# 贪心算法  
每一步都做出一个局部最优的选择，最终的结果就是全局最优。  



# 回溯  
解决一个回溯问题，实际上就是一个决策树的遍历过程，需要思考3个问题：  
1. 路径：就是已经做出的选择  
2. 选择列表：当前可以做的选择  
3. 结束条件：就是到达决策树底层，无法再做选择的条件  

问题：全排列，N皇后问题

## 回溯框架  
```
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择 
        backtrack(路径, 选择列表)
        撤销选择
```
> 核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」  

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：  
```
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```  
写backtrack函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。

## dfs  

## bfs  
BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多。  
```
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}

```

# 递归  
















