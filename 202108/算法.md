
# 动态规划  

动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的。  
这种多阶段最优化决策解决问题的过程就称为动态规划。  
与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的  

形式：求最值，最长递增子序列，最小编辑距离
核心问题：穷举  
组成：存在**重叠子问题**，具备**最优子结构**，列出正确的**状态转移方程**  
状态转移方程：明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。  
1. 确定 base case
2. 确定「状态」，也就是原问题和子问题中会变化的变量  
3. 确定「选择」，也就是导致「状态」产生变化的行为  
4. 明确 dp 函数/数组的定义  

动态规划套路流程：  
1. 明确两点，状态和选择  
2. 明确dp数组的定义  
3. 根据选择，思考状态转移的逻辑  

# 贪心算法  
每一步都做出一个局部最优的选择，最终的结果就是全局最优。  
贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。  


# 回溯  
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。  
## 算法步骤：
1. 针对所给问题，确定问题的解空间;  
1. 首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解;  
1. 确定结点的扩展搜索规则;  
1. 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。  

解决一个回溯问题，实际上就是一个决策树的遍历过程，需要思考3个问题：  
1. 路径：就是已经做出的选择  
2. 选择列表：当前可以做的选择  
3. 结束条件：就是到达决策树底层，无法再做选择的条件  

问题：全排列，N皇后问题

## 回溯框架  
```
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择 
        backtrack(路径, 选择列表)
        撤销选择
```
> 核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」  

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：  
```
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```  
写backtrack函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。

## dfs  

## bfs  
BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多。  
```
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}

```

# 递归  



# LRU算法 
最近使用的放在前边（最左边），最近没用的放到后边（最右边），来了一个新的数，如果内存满了，把旧的数淘汰掉  
解决方案：链表（处理新老关系）+ 哈希（查询在不在）  

1. 底层应该用链表，按照数据的新旧程度来排列，旧的在左边，新的在右边，新来一个加到尾部，删除是删头,除了这两个操作，还有就是把一个数据从中间拿出来放尾巴上（这个数组就很难做到）

2. 这里还有一个需求，就是要知道这个数据有没有存在于链表中，如果不在链表中，加到尾巴即可，如果已经在链表中，就只要更细数据的位置,如何查找这个数据在不在呢，这就用哈希表。

3. 考虑删除操作，要把当前节点的前一个节点的指针的改变，获取它前一个节点，方便的数据结构就是 双向链表
数据结构就是 LinkedListLinkedList (底层是双向链表)+ HashMapHashMap  
也直接用 LinkedHashMapLinkedHashMap 更为方便。  
ps：其实也可以用单链表，只要在 mapmap 中不存当前节点，而是存当前节点的前驱即可。  

解法1：使用LinkedHashMap  

# 快速幂  
快速幂，以logN的时间复杂度计算乘方。  
计算a的n次方，如果n是偶数（不为0），那么就先计算a的n/2次方，然后平方；如果n是奇数，那么就先计算a的n-1次方，再乘上a；递归出口是a的0次方为1。  

‘<<’左移：右边空出的位置补0，其值相当于乘以2。  
‘>>’右移：左边空出的位，如果是正数则补0，若为负数则补0或1，取决于所用的计算机系统OS X中补1。其值相当于除以2。  

## 分支限界  
按广度优先策略搜索问题的解空间树，在搜索过程中，对待处理的节点根据限界函数估算目标函数的可能取值，从中选取使目标函数取得极值（极大或极小）的结点优先进行广度优先搜索，从而不断调整搜索方向，尽快找到问题的解。分支限界法适合求解最优化问题。  

### 分支限界法与回溯法：  
求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。

搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树  

### 分支限界法思想：  
分支限界法首先要确定一个合理的限界函数，并根据限界函数确定目标函数的界[down ,up]，按照广度优先策略搜索问题的解空间树，在分直结点上依次扩展该结点的孩子结点，分别估算孩子结点的目标函数可能值，如果某孩子结点的目标函数可能超出目标函数的界，则将其丢弃；否则将其加入待处理结点表（简称PT表），依次从表PT中选取使目标函数取得极值的结点成为当前扩展结点，重复上述过程，直到得到最优解。   


## 分治  
分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。
  
分治法所能解决的问题一般具有以下几个特征：

1. 该问题的规模缩小到一定的程度就可以容易地解决;  
2. 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。  
3. 利用该问题分解出的子问题的解可以合并为该问题的解；  
4. 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。  

分治法在每一层递归上都有三个步骤：

分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；  
解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题;  
合并：将各个子问题的解合并为原问题的解。  

















