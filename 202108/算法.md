
# 动态规划  
形式：求最值，最长递增子序列，最小编辑距离
核心问题：穷举  
组成：存在**重写子问题**，具备**最优子结构**，列出正确的**状态转移方程**  
状态转移方程：明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。  
1. 确定 base case
2. 确定「状态」，也就是原问题和子问题中会变化的变量  
3. 确定「选择」，也就是导致「状态」产生变化的行为  
4. 明确 dp 函数/数组的定义  

动态规划套路流程：  
1. 明确两点，状态和选择  
2. 明确dp数组的定义  
3. 根据选择，思考状态转移的逻辑  

# 贪心算法  
每一步都做出一个局部最优的选择，最终的结果就是全局最优。  



# 回溯  
解决一个回溯问题，实际上就是一个决策树的遍历过程，需要思考3个问题：  
1. 路径：就是已经做出的选择  
2. 选择列表：当前可以做的选择  
3. 结束条件：就是到达决策树底层，无法再做选择的条件  

问题：全排列，N皇后问题

## 回溯框架  
```
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择 
        backtrack(路径, 选择列表)
        撤销选择
```
> 核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」  

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：  
```
def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
```  
写backtrack函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。

## dfs  

## bfs  
BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多。  
```
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}

```

# 递归  



# LRU算法 
最近使用的放在前边（最左边），最近没用的放到后边（最右边），来了一个新的数，如果内存满了，把旧的数淘汰掉  
解决方案：链表（处理新老关系）+ 哈希（查询在不在）  

1. 底层应该用链表，按照数据的新旧程度来排列，旧的在左边，新的在右边，新来一个加到尾部，删除是删头,除了这两个操作，还有就是把一个数据从中间拿出来放尾巴上（这个数组就很难做到）

2. 这里还有一个需求，就是要知道这个数据有没有存在于链表中，如果不在链表中，加到尾巴即可，如果已经在链表中，就只要更细数据的位置,如何查找这个数据在不在呢，这就用哈希表。

3. 考虑删除操作，要把当前节点的前一个节点的指针的改变，获取它前一个节点，方便的数据结构就是 双向链表
数据结构就是 LinkedListLinkedList (底层是双向链表)+ HashMapHashMap  
也直接用 LinkedHashMapLinkedHashMap 更为方便。  
ps：其实也可以用单链表，只要在 mapmap 中不存当前节点，而是存当前节点的前驱即可。  

解法1：使用LinkedHashMap  

# 快速幂  
快速幂，以logN的时间复杂度计算乘方。  
计算a的n次方，如果n是偶数（不为0），那么就先计算a的n/2次方，然后平方；如果n是奇数，那么就先计算a的n-1次方，再乘上a；递归出口是a的0次方为1。  

‘<<’左移：右边空出的位置补0，其值相当于乘以2。  
‘>>’右移：左边空出的位，如果是正数则补0，若为负数则补0或1，取决于所用的计算机系统OS X中补1。其值相当于除以2。  


