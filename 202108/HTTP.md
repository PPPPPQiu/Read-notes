# HTTP  
《图解HTTP》  
超文本传输协议，是互联网上应用最为广泛的一种网络协议。  

### HTTP请求报文  
请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。  
**请求报文结构：**   
  - 请求行，包含了请求方法、URL、HTTP版本  
  - 首部字段，包括请求首部字段、通用首部字段、实体首部字段   
  - 请求的内容主体  

### HTTP响应报文  
响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。  
**响应报文结构：**  
  - 状态行，包含协议版本、状态码以及描述  
  - 首部字段，包括响应首部字段、通用首部字段、实体首部字段    
  - 响应的内容主体  


### HTTP不保存状态的协议  
HTTP 协议自身不对请求和响应之间的通信状态进行保存。  
也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。  
这是为了更快地处理大量事务，确保协议的可伸缩性。  


### HTTP请求方法  
GET:获取资源  
HEAD:获取报文首部，主要用于确认URL的有效性以及资源更新的日期时间  
POST：传输实体主体  
PUT：上传文件  
PATCH：对资源进行部分修改  
DELETE：删除文件  
OPTIONS：查询支持的方法  
CONNECT：要求在与代理服务器通信时建立隧道  
TRACE：追踪路径  

### GET和POST的区别  
1. 作用：get是获取数据，post是传输实体主体 
2. 参数：get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&相连。而post把数据放在HTTP的包体内 
3. 大小：get提交的数据最大是2k（限制实际上取决于浏览器）， post理论上没有限制。  
4. 安全：GET安全（只读，不改变服务器状态），POST不安全  
5. GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。   
6. 缓存：GET请求会被浏览器主动缓存，而POST不会，除非手动设置。  
7. 幂等：本质区别——GET是幂等的，而POST不是幂等的  


### HTTP请求过程包括哪些内容  
域名解析 -->    
发起TCP的3次握手 -->    
建立TCP连接后发起http请求 -->    
服务器响应http请求，浏览器得到html代码 -->   
浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） -->   
浏览器对页面进行渲染呈现给用户。  




### HTTP首部  
通用首部字段  
1. Cache-Control：操作缓存的工作机制  
  缓存请求指令：max-age 响应的最大Age值，min-fresh期望在指定时间内的响应仍有效  no-cache  no-store  
  缓存响应指令：max-age 响应的最大Age值，s-maxage 公共缓存服务器响应的最大Age值  public  private  
2. Connection：控制不再转发给代理的首部字段，管理持久连接，keep-Alive  
3. Trailer：事先说明在报文主体后记录了哪些首部字段。 Expires  
4. Warning  

请求首部字段  
1. Accept：通知服务器，用户代理能够处理的媒体类型及相对优先级  
2. Accept-Charset：通知服务器，用户代理能够处理的字符集及相对优先顺序  
3. Accept-Encoding：通知服务器，用户代理能够处理的内容编码及相对优先顺序  
4. Accept-Language：通知服务器，用户代理能够处理的自然语言集及相对优先顺序  

响应首部字段  
1. Accept-Ranges：通知客户端是否能处理范围请求  
2. Age：告知客户端，源服务器多久前创建了响应  
3. ETag：服务器为每份资源分配的字符串标识  

实体首部字段  
1. Allow：通知客户端支持的HTTP方法  
2. Content-Encoding/Language/Length：告知客户端，实体主体的内容编码方式/自然语言/大小  
3. Expires：将资源失效的日期告知客户端  
4. Last-Modified：资源最终修改的时间  

Cookie  
响应首部字段：Set-Cookie  
expires，Cookie的有效期
请求首部字段：Cookie，服务器接受到的



#### 通用首部字段  
![3N@N5$PX O2ZEPK}K2W_2C6](https://user-images.githubusercontent.com/87803098/130759105-34308808-040d-4510-ac7a-4e16117343d9.png)


#### 请求首部字段  
![AUHO}G1G~26J6 YUI{`_$FS](https://user-images.githubusercontent.com/87803098/130759203-5805aae5-1bde-475c-aa20-df7d8fe26976.png)


#### 响应首部字段  
![LFTK`AF2EKO_Z2K44@OZFCL](https://user-images.githubusercontent.com/87803098/130759282-d009dd01-6067-4b1d-9c21-7b8ee7dd3b03.png)


#### 实体首部字段  

![{3IZ0O4T5C`~75D VX0}GZ6](https://user-images.githubusercontent.com/87803098/130759328-d2ecd04b-0262-4777-b270-dd18b4edd017.png)




### 在浏览器中输入URL地址  
根据域名，进行DNS域名解析；  
拿到解析的IP地址，建立TCP连接；  
向IP地址，发送HTTP请求；  
服务器处理请求；  
返回响应结果；  
关闭TCP连接；  
浏览器解析HTML；  
浏览器布局渲染；  


## HTTPS  
超文本传输安全协议  
通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。  
请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击。  


HTTPS 采用混合加密机制  
1. 使用非对称密钥加密方式安全的交换对称密钥加密中要使用的密钥   
2. 确保交换的密钥是安全的前提下，使用对称密钥加密的方式进行通信   


证明公开密钥正确性的证书
1. 服务器把自己的公开密钥登录至数字证书认证机构  
2. 数字认证机构用自己的私有密钥向服务器的公开密码署数字签名并颁发公钥证书（包括服务器的公开密钥、数字证书认证机构的数字签名）   
3. 客户端拿到服务器的公钥证书后，使用数字证书认证机构的公开密钥，向数字证书认证机构验证公钥证书上的数字签名，以确认服务器的公开密钥的真实性  
4. 使用服务器的公开密钥对报文加密后发送  




### HTTP和HTTPS区别  
1. 端口 ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。  
2. 安全性和资源消耗： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。  
  - 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；  
  - 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。  

### Cookie  
Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据  


### Session  
Session 可以存储在服务器上的文件、数据库或者内存中。  
步骤 1： 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS通信来进行 HTML表单画面的显示和用户输入数据的发送。  
步骤 2： 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。  
步骤 3： 客户端接收到从服务器端发来的 Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。  

### Cookie和Session的区别  

Cookie 一般用来保存用户信息；Session 的主要作用就是通过服务端记录用户的状态。  
Cookie和Session都是客户端与服务器之间保持状态的解决方案  
1，存储的位置不同，cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全  
2，存储的数据类型不同  
两者都是key-value的结构，但针对value的类型是有差异的  
cookie：value只能是字符串类型，session：value是Object类型  
3，存储的数据大小限制不同  
cookie：大小受浏览器的限制，很多是是4K的大小， session：理论上受当前内存的限制，  
4，生命周期的控制  
cookie的生命周期当浏览器关闭的时候，就消亡了  
(1)cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束，  
(2)session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁  




### 缓存  
有缓存服务器，和，客户端的缓存





### HTTP状态码  
1XX 信息  
100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。  
2XX 成功  
200 OK  

204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。  

206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。  

#3XX 重定向  
301 Moved Permanently ：永久性重定向  

302 Found ：临时性重定向  

303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。  

注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。  

304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。  

307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。  

#4XX 客户端错误  
400 Bad Request ：请求报文中存在语法错误。  

401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。  

403 Forbidden ：请求被拒绝。  

404 Not Found    

#5XX 服务器错误  
500 Internal Server Error ：服务器正在执行请求时发生错误。  

503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。   



### 持久连接  
#### 长连接  
#### 管线化  
#### 分块传输编码  
#### 获取部分内容的范围请求  
执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。
#### 内容协商  
1. 服务器驱动协商  
2. 客户端驱动协商  
3. 透明协商  



### 代理、网关、隧道  
代理
代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。  
网关  
网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。  
隧道  
隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。  
 


## HTTP们的区别  
### HTTP1.0和HTTP1.1  
1. 长连接  
> HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。

3. 节约带宽  
> HTTP1.1支持只发送header信息  

4. HOST域  
> HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。

5. 缓存处理  
> 更多可供选择的缓存头来控制缓存策略  


7. 错误通知的管理  
409：表示请求的资源与资源的当前状态发生冲突   
410：表示服务器上的某个资源被永久性的删除  


### HTTP1.1和HTTP2.0   
- 二进制分帧 
HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

- 多路复用  
做到同一个连接并发处理多个请求  
- 头部数据压缩  
HTTP2.0使用HPACK算法对header的数据进行压缩  

- 服务器推送  
服务端推送是一种在客户端请求之前发送数据的机制。  
HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。  


### HTTP/1.1 新特性
- 默认是长连接  
- 支持流水线  
- 支持同时打开多个 TCP 连接  
- 支持虚拟主机  
- 新增状态码 100  
- 支持分块传输编码  
- 新增缓存处理指令 max-age



