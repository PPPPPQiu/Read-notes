# Java基础  

## 对Java的理解  
- 简单易学  
- 面向对象  
- 平台无关性  
- 支持多线程  
- 可靠性、安全性  
- 支持网络编程并且很方便  
- 编译与解释并存  

## 对JVM的理解  
Java虚拟机是运行Java字节码的虚拟机，JVM有针对不同系统的特定实现，目的是使用相同的字节码，他们都会给出相同的结果。  
“一次编译，随处可以运行”  

## 面向对象  
### 封装  
封装，是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。  
主要任务是对属性、数据、敏感行为实现隐藏，使对象关系变得简单，降低耦合。  
### 继承  
继承用来扩展类，子类可继承父类的部分属性和行为，使模块具有复用性。  
继承，是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。  
通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。  
### 多态  
多态以封装和继承为基础，根据运行时对象实际类型使同一行为具有不同表现形式。  
多态，表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。  
多态指在编译层面无法确定最终调用的方法体，在运行期由 JVM 动态绑定，调用合适的重写方法。  
由于重载属于静态绑定，本质上重载结果是完全不同的方法，因此多态一般专指重写。  

## static  
this、super 不能用在 static 方法中  
### 静态变量  
静态变量 存放在 Java 内存区域的方法区  
### 静态代码块  
静态代码块—>非静态代码块—>构造方法  
静态代码块只执行一次  

### 静态内部类  
静态内部类与非静态内部类之间存在一个最大的区别:  
**非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。**  
没有这个引用就意味着：
**1. 它的创建是不需要依赖外围类的创建。**   
**2. 它不能使用任何外围类的非 static 成员变量和方法。**  

当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance()方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。

这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。


### 静态方法  
静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法  

### 存在继承的情况下，初始化顺序为：  
- 父类（静态变量、静态语句块）  
- 子类（静态变量、静态语句块）  
- 父类（实例变量、普通语句块）  
- 父类（构造函数）  
- 子类（实例变量、普通语句块）  
- 子类（构造函数）  

## 重载与重写  
### 重载  
发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。  
重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。  

### 重写  
重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。  
重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变  
- “两同”即方法名相同、形参列表相同；  
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；  
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。  

## String  
### String StringBuffer 和 StringBuilder 的区别
- String：不可变，线程安全  
- StringBuilder：可变，非线程安全  
- StringBuffer：可变，线程安全  


## 反射  
反射是在运行状态中，  
对于任意一个类，都能够知道这个类的所有属性和方法；  
对于任意一个对象，都能够调用它的任意一个方法和属性；  
这种动态获取的信息以及动态调用对象的方法的功能称为反射机制。  

反射赋予了我们在运行时分析类以及执行类中方法的能力。  
通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。  
优点：灵活，便利  
确定：增加安全问题，性能差  


## 抽象类和接口
抽象类是对类的抽象，接口是对行为的抽象  
抽象类是对整个类的整体进行抽象，包括属性、行为，接口却是对类局部（行为）进行抽象  

抽象类不一定含有抽象方法，接口中的所有方法必须是抽象方法    
接口的字段只能是static final字段，接口的成员只能是public  
抽象类有构造方法，接口没有构造方法  
一个类可以实现多个接口，但是不能继承多个抽象类  


继承抽象类的关键字为extends，接口的为implements  

## 异常  

## IO流  
- 字节操作：InputStream 和 OutputStream  
- 字符操作：Reader 和 Writer  

### 装饰者模式  

### 序列化  
Java 对象在 JVM 退出时会全部销毁，如果需要将对象持久化就要通过序列化实现，将内存中的对象保存在二进制流中，需要时再将二进制流反序列化为对象。  
对象序列化保存的是对象的状态，属于类属性的静态变量不会被序列化。  

### NIO







# Java容器  

## Java集合  
Collection：List，Set，Queue  
Map：SortedMap（TreeMap），HashMap，HashTable  
  
细分：  
List：Vector（Stack），ArrayList，LinkedList  
> 有序，可重复  

Set：SortedSet（TreeSet），HashSet，LinkedHashSet  
> 无序，不可重复  

Queue：Deque（ArrayDeque，LinkedList），PriorityQueue  
> 有序，可重复  

### 线程安全否？  
安全：
- Vector  
- CopyOnWriteArrayList  
- ConcurrentHashMap  
- HashTable  
- BlockingQueue  
- ConcurrentLinkedQueue  
> 高效的并发队列，链表实现，线程安全的LinkedList，非阻塞队列  

- ConcurrentSkipListMap  
> 跳表实现，一个Map


不安全：
- ArrayList   
- LinkedList  
- HashSet  
- TreeSet  
- HashMap  
- TreeMap  


## List
### ArrayList  
数组，线程不安全    
#### 扩容：新容量是旧容量的1.5倍  

### Vector  
数组，线程安全    
#### 扩容：新容量是旧容量的2倍  

### CopyOnWriteArrayList  
写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。

写操作需要加锁，防止并发写入时导致写入数据丢失。

写操作结束之后需要把原始数组指向新的复制数组。


### LinkedList  
双向链表  


## Set
### HashSet  
基于 HashMap 实现的  
> 无序，不可重复  


### LinkedHashSet  
通过 LinkedHashMap 来实现

### TreeSet  
红黑树
> 有序，不可重复  



## Queue  
### ArrayQueue  
数组 + 双指针  

### PriorityQueue  
基于堆结构实现    
线程不安全  
- 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据  
- 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素  

## Map

### TreeMap  
红黑树（自平衡的排序二叉树）  

### HashMap  
基于哈希表实现。  
线程不安全  
数组+链表 || 数组+红黑树  

#### 扩容：动态扩容，主要参数有：capacity、size、threshold 和 load_factor  
#### 扩容：新容量是旧容量的2倍  

### ConcurrentHashMap  
ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。  
#### JDK 1.7 ：分段的数组+链表 ，使用分段锁机制来实现并发更新操作。  
> 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高。  
> 并发度就是 Segment 的个数   
> Segment 继承自 ReentrantLock。  
#### JDK 1.8 ：数组+链表/红黑二叉树，并发控制使用 synchronized 和 CAS 来操作  
> 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized  

### LinkedHashMap  

数组+链表 || 数组+红黑树 的基础上增加了一条双向链表  
使用双向链表来维护元素的顺序  

### HashTable  
线程安全，使用 synchronized 来进行同步    
数组+链表  
#### 扩容：新容量是旧容量的2n + 1倍  






































