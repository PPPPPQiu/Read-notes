## 排序总结  
稳定排序：冒泡排序、插入排序、归并排序  
时间复杂度低的排序（NlogN）：快速排序、归并排序、堆排序  





## 快速排序  
**算法思想**

1、选取第一个数为基准

2、将比基准小的数交换到前面，比基准大的数交换到后面

3、对左右区间重复第二步，直到各区间只有一个数



## 堆排序  
堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。  
位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。  
### 1. 构建堆：从右至左进行下沉操作
如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。  
叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。  

### 2. 交换堆顶元素与最后一个元素
交换之后需要进行下沉操作维持堆的有序状态。  




## 归并排序
归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。  

**算法思想**

1、把长度为n的输入序列分成两个长度为n/2的子序列；

2、对这两个子序列分别采用归并排序；

3、 将两个排序好的子序列合并成一个最终的排序序列。

## 希尔排序  
希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。

希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。  



## 冒泡排序改进  
O(n)
设置一个是否提前结束排序的标记  
```
public void sort(int[] arr) {
        boolean flag;
        for (int j = arr.length; j > 0; j--) {
            flag = false;
            for (int i = 0; i < j - 1; i++) {
                int next = i + 1;
                if (arr[i] > arr[next]) {
                    swap(arr, i, next); //换位
                    flag = true;
                }
            }
            if (!flag) {
                return;
            }
        }
    }

```






























