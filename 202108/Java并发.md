# Java并发  

### 线程同步的方式  
1. 信号  
2. 锁机制  
3. 条件变量  
4. 信号量  

#### 典型的锁机制  
1. 读写锁  
2. 互斥锁  
3. 条件变量  
4. 自旋锁  

线程锁：互斥锁，条件变量，自旋锁  

### 进程同步的方式  
1. 临界区  
2. 同步与互斥   
3. 信号量  
4. 管程  

### 进程间通信的方式  
1. 管道  
2. 命名管道  
3. 共享内存  
4. 消息队列  
5. 信号量  
6. 套接字  

## sychronized  
JVM 实现的 synchronized  
synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。  

###  sychronized实现  
synchronized 属于 重量级锁，效率低下。  
因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。  
如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。  
在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。    

### sychronized底层原理    
synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。

synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。

不过两者的本质都是对对象监视器 monitor 的获取。

#### 同步语句块  
synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，  
其中 monitorenter 指令指向同步代码块的开始位置，  
monitorexit 指令则指明同步代码块的结束位置。  
当执行 monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。  
在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。  
在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。  

#### 修饰方法  
synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。    
JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。  


### sychronized的三种使用方法  
1. 修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁  
2. 修饰静态方法：给当前类加锁  
3. 修饰代码块：this|object获得给定对象的锁，类.class表示获得当前class的锁  

总结：
- synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。  
- synchronized 关键字加到实例方法上是给对象实例上锁。  

### sychronized和ReentrantLock的区别  

#### 1. 都是可重入锁  
#### 2. synchronized依赖于JVM而ReentrantLock依赖于API  
#### 3. ReentrantLock有一些高级功能：等待可中断，可实现公平锁，可实现选择性通知  
#### 4. 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等  

## volatile  
声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。  
volatile 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。  

### sychronized和volatile的区别
1. volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。  
2. volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。  
3. volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。  

## 优化后的sychronized锁  
> CAS(比较并交换) 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。  


### 偏向锁  
偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。  
当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。  
当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。   

### 轻量级锁  
轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。  
对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。  

### 自旋锁
自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。  

### 锁消除  
锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。  

### 锁粗化  



## 线程池  
线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。  
好处：降低资源消耗，提高响应速度，提高线程的可管理性  

### 线程池参数  
corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。  
maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。  
workQueue: 任务队列，用来储存等待执行任务的队列  
  
keepAliveTime:当线程数大于核心线程数时，多余的空闲线程存活的最长时间  
unit : keepAliveTime 参数的时间单位。   
threadFactory :线程工厂，用来创建线程
handler :饱和策略。  


### 线程池种类  
- FixedThreadPool ： 该方法返回一个固定线程数量的线程池。  
- SingleThreadExecutor： 方法返回一个只有一个线程的线程池。  
- CachedThreadPool： 该方法返回一个可根据实际情况调整线程数量的线程池。  


### 饱和策略  


### 线程池大小确定  
多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，CPU 采取的策略是为每个线程分配时间片并轮转的形式。  
任务从保存到再加载的过程就是一次上下文切换。  

CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。  
I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。  

CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。  

### Executor  
1. 主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。  
2. 把创建完成的实现 Runnable/Callable接口的 对象直接交给 ExecutorService 执行:   
3. 如果执行 ExecutorService.submit（…），ExecutorService 将返回一个实现Future接口的对象  
4. 最后，主线程可以执行 FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel来取消此任务的执行。  


## AQS  
AQS是一个用来构建锁和同步器的框架，这个类在java.util.concurrent.locks包下面。  
AQS 核心思想是：  
如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。  
如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。  


### AQS组件  
Semaphore(信号量)-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。  
CountDownLatch （倒计时器）： CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。  
CyclicBarrier(循环栅栏)： CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。       
它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。  


