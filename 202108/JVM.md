

## 运行时数据区域  
线程共享：  
堆—— Eden 空间、From Survivor、To Survivor 空间  
方法区—— 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据    
直接内存  


线程私有：  
程序计数器  
虚拟机栈  
本地方法栈  

# 垃圾收集  
## 判断垃圾方法  
引用计数法  
GC Roots包含的内容：  
#### 虚拟机栈和本地方法栈中引用的对象
#### 方法区：类静态属性和常量引用的对象  

## 引用类型  
强引用  
软引用  
弱引用  
虚引用  

## 垃圾收集算法  
1. 标记-清除  
2. 标记-整理  
3. 复制  
4. 分代收集  
> 新生代用复制，老年代用清除或整理  

## 垃圾收集器  
新生代：  
#### 1. Serial，单线程：新生代采用标记-复制算法，老年代采用标记-整理算法。  
#### 2. ParNew，多线程：新生代采用标记-复制算法，老年代采用标记-整理算法。  
#### 3. Parallel Scavenge：新生代采用标记-复制算法，老年代采用标记-整理算法。   
老年代：  
#### 1. Serial Old  
#### 2. Parallel Old  
#### 3. CMS  
初始标记，并发标记，重新标记，并发清除  
停，不停，停，不停  

常用的：
#### 1. G1  
初始标记，并发标记，最终标记，筛选回收  
停，不停，停，停  
G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region。  

#### 2. ZGC
JDK11推出，低延迟垃圾回收器   
设计目标：停顿时间小于10ms，停顿时间不随堆或活跃对象的大小而增加，支持8MB-4TB的堆  
着色指针和读屏障技术  
> https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html

## 内存分配与回收策略  

Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。  
Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。  

### 内存分配策略  
- 对象优先在 Eden 分配  
- 大对象直接进入老年代  
> 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。  

- 长期存活的对象进入老年代  
- 动态对象年龄判定  
- 空间分配担保  

### Full GC 的触发条件  




# 类加载机制  
JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行验证、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。  
## 类加载过程  
加载，验证，准备，解析，初始化  

> 类的生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载  


## 类加载器分类  
启动类加载器  
扩展类加载器  
应用程序类加载器  

## 双亲委派模型  
双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父加载器。

一个类加载器收到了类加载请求，不会自己去尝试加载，而将该请求委派给父加载器，每层的类加载器都是如此，因此所有加载请求最终都应该传送到启动类加载器，只有当父加载器反馈无法完成请求时，子加载器才会尝试。

类跟随它的加载器一起具备了有优先级的层次关系，确保某个类在各个类加载器环境中都是同一个，保证程序的稳定性。


双亲委派模型，指的是类加载器之间的层次关系。  
除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。  
这里的父子关系一般通过组合关系来实现，而不是继承关系  

### 工作过程  
一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。  

### 好处  
使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。  





## JMM-Java内存模型  
Java内存模型规定了所有的变量都存储在主内存中，每条线程都有自己的工作内存，线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，  
线程对变量的所有操作必须在工作内存中进行，而不能直接读写主内存。  
不同的线程之间也是无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主内存之间进行数据同步进行。  

JMM就作用于工作内存和主内存之间数据同步过程。  
主内存主要对应于Java堆中的对象实例数据部分。  
工作内存则对应于虚拟机栈中的部分区域。

JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。  

> https://www.jianshu.com/p/8420ade6ff76  


### 原子性  
synchronized来保证方法和代码块中的操作是原子性的  

### 可见性  
volatile  
final  
synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。  

### 有序性  
volatile  
synchronized  















