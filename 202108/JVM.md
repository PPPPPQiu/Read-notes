

## 运行时数据区域  
线程共享：  
堆——，存放对象实例，新生代：Eden 空间、From Survivor、To Survivor 空间  
方法区—— 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据    
直接内存  


线程私有：  
程序计数器  
虚拟机栈：栈帧（局部变量表-各种数据类型、对象引用，操作数栈，动态链接，方法出口信息）  
本地方法栈：存放该本地方法的局部变量表、操作数栈、动态链接、出口信息    

# 垃圾收集  
## 判断垃圾方法  
引用计数法  
GC Roots包含的内容：  
#### 虚拟机栈和本地方法栈中引用的对象
#### 方法区：类静态属性和常量引用的对象  
#### 所有被同步锁持有的对象  

## 引用类型  
强引用  
软引用  
弱引用  
虚引用  
虚引用主要用来跟踪对象被垃圾回收的活动。  

## 垃圾收集算法  
1. 标记-清除  
2. 标记-整理  
3. 复制  
4. 分代收集  
> 新生代用复制，老年代用清除或整理  

## 垃圾收集器  
新生代：  
#### 1. Serial，单线程：新生代采用标记-复制算法，老年代采用标记-整理算法。  
#### 2. ParNew，多线程：新生代采用标记-复制算法，老年代采用标记-整理算法。  
#### 3. Parallel Scavenge：新生代采用标记-复制算法，老年代采用标记-整理算法。   
老年代：  
#### 1. Serial Old  
#### 2. Parallel Old  
#### 3. CMS  
初始标记，并发标记，重新标记，并发清除  
停，不停，停，不停  
主要优点：并发收集、低停顿  
三个明显的缺点：  
对 CPU 资源敏感；  
无法处理浮动垃圾；  
它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。  

常用的：
#### 1. G1  
特点：并行与并发、分代收集、空间整合、可预测的停顿  
初始标记，并发标记，最终标记，筛选回收  
停，不停，停，停  
G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region。  



#### 2. ZGC
JDK11推出，低延迟垃圾回收器   
设计目标：停顿时间小于10ms，停顿时间不随堆或活跃对象的大小而增加，支持8MB-4TB的堆  
着色指针和读屏障技术  
> https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html

## 内存分配与回收策略  

Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。  
Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。  

部分收集 (Partial GC)：  

新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；  
老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；  
混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。  
整堆收集 (Full GC)：收集整个 Java 堆和方法区。  

空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。  

### 内存分配策略  
- 对象优先在 Eden 分配  
- 大对象直接进入老年代  
> 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。  

- 长期存活的对象进入老年代  
- 动态对象年龄判定  
- 空间分配担保  

### Full GC 的触发条件  




# 类加载机制  
JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行验证、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。  
## 类加载过程  
加载，验证，准备，解析，初始化  

> 类的生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载  


## 类加载器分类  
启动类加载器  
扩展类加载器  
应用程序类加载器  

## 双亲委派模型  
双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父加载器。

一个类加载器收到了类加载请求，不会自己去尝试加载，而将该请求委派给父加载器，每层的类加载器都是如此，因此所有加载请求最终都应该传送到启动类加载器，只有当父加载器反馈无法完成请求时，子加载器才会尝试。

类跟随它的加载器一起具备了有优先级的层次关系，确保某个类在各个类加载器环境中都是同一个，保证程序的稳定性。


双亲委派模型，指的是类加载器之间的层次关系。  
除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。  
这里的父子关系一般通过组合关系来实现，而不是继承关系  

### 工作过程  
一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。  

### 好处  
使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。  





## JMM-Java内存模型  
Java内存模型规定了所有的变量都存储在主内存中，每条线程都有自己的工作内存，线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，  
线程对变量的所有操作必须在工作内存中进行，而不能直接读写主内存。  
不同的线程之间也是无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主内存之间进行数据同步进行。  

JMM就作用于工作内存和主内存之间数据同步过程。  
主内存主要对应于Java堆中的对象实例数据部分。  
工作内存则对应于虚拟机栈中的部分区域。

JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。  

> https://www.jianshu.com/p/8420ade6ff76  


### 原子性  
synchronized来保证方法和代码块中的操作是原子性的  

### 可见性  
volatile  
final  
synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。  

### 有序性  
volatile  
synchronized  



## JDK监控和故障处理工具总结  
jps:查看所有 Java 进程  
jstat: 监视虚拟机各种运行状态信息  
jinfo: 实时地查看和调整虚拟机各项参数  
jmap:生成堆转储快照  
jhat: 分析 heapdump 文件  
jstack :生成虚拟机当前时刻的线程快照  



## 对象的创建  
对象创建过程：  
1. 类加载检查：先检查这个指令的参数是否能在常量池中定位到一个类的引用符号，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，没有则进行类加载过程。  
2. 分配内存：为对象分配空间，相当于把一块确定大小的内存从Java堆中划分出来  
3. 初始化零值：虚拟机将分配到的内存空间都初始化置零，保证了对象的实例在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值  
4. 设置对象头：对对象进行必要的设置，如这个对象是哪个类的实例、对象的哈希码、对象的GC分代年龄等信息都存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。  
5. 执行init方法：根据构造方法进行对象的初始化

## 对象的内存分配  
1. 指针碰撞法  
主要就是假设JVM中的内存是绝对规整的，使用过的内存和未使用过的内存分别放在两边，用一个指针来给他们做区分。如果要分配内存，只需要将指针向空闲的那一端移动对象大小的位置就好了。 
2. 空闲列表法
如果JAVA堆中的内存分配并不是规整的，那么久需要一张表来记录某些还未分配的内存大小，当需要进行内存分配的时候从表中找到足够大小的内存区域来完成分配，并更新列表上的区域。  


## Java对象分配  
### 栈上分配  
如果确定一个对象的作用域不会逃逸出方法之外，那可以将这个对象分配在栈上，这样，对象所占用的内存空间就可以随栈帧出栈而销毁。  
JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。  
栈上分配的技术基础：   

一是逃逸分析：逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。  

二是标量替换：允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。  



本质：Java虚拟机提供的一项优化技术

基本思想： 将线程私有的对象打散分配在栈上

优点：

可以在函数调用结束后自行销毁对象，不需要垃圾回收器的介入，有效避免垃圾回收带来的负面影响

栈上分配速度快，提高系统性能

局限性： 栈空间小，对于大对象无法实现栈上分配

技术基础： 逃逸分析

逃逸分析的目的： 判断对象的作用域是否超出函数体[即:判断是否逃逸出函数体]

### TLAB  
线程本地分配缓存区，这是一个线程专用的内存分配区域。  
JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。  
TLAB本身占用Eden区空间，在开启TLAB的情况下，虚拟机会为每个Java线程分配一块TLAB空间。  
TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。  

为什么需要TLAB？  

这是为了加速对象的分配。由于对象一般分配在堆上，而堆是线程共用的，因此可能会有多个线程在堆上申请空间，而每一次的对象分配都必须线程同步，会使分配的效率下降。考虑到对象分配几乎是Java中最常用的操作，因此JVM使用了TLAB这样的线程专有区域来避免多线程冲突，提高对象分配的效率。  

局限性： TLAB空间一般不会太大（占用eden区），所以大对象无法进行TLAB分配，只能直接分配到堆上。  



















