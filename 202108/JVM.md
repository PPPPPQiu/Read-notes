

## 运行时数据区域  
线程共享：  
堆—— Eden 空间、From Survivor、To Survivor 空间  
方法区—— 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据    
直接内存  


线程私有：  
程序计数器  
虚拟机栈  
本地方法栈  

# 垃圾收集  
## 判断垃圾方法  
引用计数法  
GC Roots包含的内容：  
#### 虚拟机栈和本地方法栈中引用的对象
#### 方法区：类静态属性和常量引用的对象  

## 引用类型  
强引用  
软引用  
弱引用  
虚引用  

## 垃圾收集算法  
1. 标记-清除  
2. 标记-整理  
3. 复制  
4. 分代收集  
> 新生代用复制，老年代用清除或整理  

## 垃圾收集器  
新生代：  
#### 1. Serial，单线程：新生代采用标记-复制算法，老年代采用标记-整理算法。  
#### 2. ParNew，多线程：新生代采用标记-复制算法，老年代采用标记-整理算法。  
#### 3. Parallel Scavenge：新生代采用标记-复制算法，老年代采用标记-整理算法。   
老年代：  
#### 1. Serial Old  
#### 2. Parallel Old  
#### 3. CMS  
初始标记，并发标记，重新标记，并发清除  
停，不停，停，不停  

常用的：
#### 1. G1  
初始标记，并发标记，最终标记，筛选回收  
停，不停，停，停  
G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region。  

## 内存分配与回收策略  

Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。  
Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。  

### 内存分配策略  
- 对象优先在 Eden 分配  
- 大对象直接进入老年代  
> 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。  

- 长期存活的对象进入老年代  
- 动态对象年龄判定  
- 空间分配担保  

### Full GC 的触发条件  




# 类加载机制  
JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行验证、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。  
## 类加载过程  
加载，验证，准备，解析，初始化  

> 类的生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载  


## 类加载器分类  
启动类加载器  
扩展类加载器  
应用程序类加载器  

## 双亲委派模型  
双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父加载器。

一个类加载器收到了类加载请求，不会自己去尝试加载，而将该请求委派给父加载器，每层的类加载器都是如此，因此所有加载请求最终都应该传送到启动类加载器，只有当父加载器反馈无法完成请求时，子加载器才会尝试。

类跟随它的加载器一起具备了有优先级的层次关系，确保某个类在各个类加载器环境中都是同一个，保证程序的稳定性。


双亲委派模型，指的是类加载器之间的层次关系。  
除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。  
这里的父子关系一般通过组合关系来实现，而不是继承关系  

### 工作过程  
一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。  

### 好处  
使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。  






























