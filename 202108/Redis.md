# Redis  
非关系型键值对数据库  
五种数据类型：字符串、列表、集合、散列表、有序集合  
支持事务、持久化、LUA脚本、LRU驱动事件、多种集群方案  
数据结构：  
1. 字典，是一个散列表结构，使用拉链法解决哈希冲突。  
2. 跳跃表，基于多指针有序链表实现，有序集合的底层实现之一  
与红黑树等平衡树相比，跳跃表具有以下优点：  
插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；  
更容易实现；  
支持无锁操作。  


- Redis优点  
1. 读写性能优异  
2. 支持数据持久化  
3. 支持事务  
4. 数据结构丰富  
5. 支持主从复制  

- 缺点  
1. 数据库容量收到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上  
2. Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复  
3. 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性  
4. Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。  

### Redis做缓存和本地内存的区别  
- 读写速度，本地内存快  
- 场景使用，同一数据，从数据库取出来，放到redis只要一次，而放到本地缓存，则需要n个集群次  
- redis内存可能n多扩充，而本地扩大堆内存代价是很大的。  
- 本地缓存需要自己实现过期功能，实现不好可能导致极其严重的后果，而redis经过大量的流量验证，许多漏洞无需考试，安全。  
- 本地缓存无法提供丰富的数据结构，redis可以。redis可以写磁盘，持久化，本地缓存不可以  
- 使用本地缓存极有可能导致严重的线程安全问题，并发考虑严重。  


- 为什么要用Redis/缓存  
1. 高性能：操作缓存就是直接操作内存，速度相当快  
2. 高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的  

- Redis为什么这么快  
1. 完全基于内存，数据存在内存中，类似于HashMap  
2. 数据结构简单，对数据操作也简单  
3. 采用单线程，避免了不必要的上下文切换和竞争条件  
4. 使用多路I/O复用模型，非阻塞I/O  
5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建VM机制  

- Redis有哪些数据类型  
包括String，List，Set，Zset，Hash  

![RNLN{Q R5K4NNA$4F N{W)F](https://user-images.githubusercontent.com/87803098/130377827-0635c86d-71d0-41c0-bc70-b947f505a7f5.png)


- Redis的应用场景  
1. 计数器  
2. 缓存  
3. 会话缓存  
4. 全页缓存  
5. 查找表  
6. 消息队列  
7. 分布式锁实现  

- 什么是Redis持久化  
持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。  

- Redis的持久化机制是什么，各自的优缺点  
两种：RDB（默认）和AOF机制  
RDB，按照一定的时间将内存的数据以快照的形式保存在硬盘中，对应产生的数据文件dump.rdb。
优点：  
1. 只有一个文件dump.rdb，方便持久化  
2. 容灾行好，一个文件可以保存到安全的磁盘  
3. 性能最大化，fork子进程完成写操作，让主进程继续处理命令，IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能  
4. 相对于数据集大时，比AOF的启动效率更高  

缺点：  
1. 数据安全性低，RDB是间隔一段时间进行持久化，适合于数据要求不严谨的情况   

![image](https://user-images.githubusercontent.com/87803098/130378269-6a6f06ef-7ca6-47f6-b66d-ce9dec15db16.png)

AOF，是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据  
优先选择AOF恢复  

优点：  
1. 数据安全，可以设置每进行一次命令操作就记录到aof文件中一次  
2. 通过append模式写文件，即使中途服务器宕机，也可以通过redis-check-aof工具解决数据一致性问题  
3. AOF机制的rewrite模式

缺点：  
1. AOF文件比RDB文件大，且恢复速度慢  
2. 数据集大时，比rdb启动效率低  

优缺点是什么？  
AOF文件比RDB更新频率高，优先使用AOF还原数据。  
AOF比RDB更安全也更大  
RDB性能比AOF好  
如果两个都配了优先加载AOF  


- Redis持久化数据和缓存怎么扩容   
缓存使用，使用一致性哈希实现动态扩容缩容  
持久化存储，使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化   

- Redis过期键的删除策略  
1. 定时过期：每个key创建一个定时器，过期立即清理。对内存友好，但会占用大量CPU资源去处理过期的数据，影响缓存的响应时间和吞吐量  
2. 惰性过期：只有当访问一个key时，才会判断key是否已过期。最大化节省了CPU资源，对内存不友好  
3. 定期过期：每隔一段时间，扫描一定数量的key。可以在不同情况下使CPU和内存资源达到最优的平衡效果  
Redis，使用惰性和定期两种  

- 过期时间：expire，永久有效：persist  

- Redis的内存淘汰策略  
指在Redis用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据  

全局的键空间选择性移除：  
noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。  
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）  
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。  


设置过期时间的键空间选择性移除：  
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。  
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。  
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。  

内存淘汰策略用于处理内存不足时的需要申请额外空间的数据，过期策略用于处理过期的缓存数据。  


- Redis线程模型  
Redis基于Reactor模式开发了网络事件处理器，称为文件事件处理器，四个组成部分：多个套接字，IO多路复用程序，文件事件分派器，事件处理器。  
文件事件处理器使用IO多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。  


- Redis事务  
Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。  
Redis事务的三个阶段：事务开始MULTI，命令入队，事务执行EXEC  
Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的  
Redis会将一个事务中的所有命令序列化，然后按顺序执行。  
Redis不支持回滚，如果在一个事务中的命令出现错误，那么所有的命令都不会执行；  
如果在一个事务中出现运行错误，那么正确的命令会被执行。


WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。  
MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。  
EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。  
通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。  
UNWATCH命令可以取消watch对所有key的监控.  
WATCH 命令用于监听指定的键，当调用 EXEC 命令执行事务时，如果一个被 WATCH 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。  

Redis的事务具有一致性和隔离性。  
隔离性：Redis是单进程程序，保证在执行事务时，不会对事务进行中断。  
不保证原子性，且没有回滚，任意命令执行失败，其余的命令仍然会被执行。  


## 缓存异常  

- 缓存雪崩  
指缓存同一时间大面积的失效，所以后面的请求都会落地数据库上，造成数据库短时间内承受大量请求而崩掉。  
解决方案：  
1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生  
2. 并发量不是特别大的时候，使用加锁排队  
3. 给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存  

- 缓存穿透  
指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。  
解决方案：  
1. 接口层增加校验，如用户健全校验，id做基础校验  
2. 从缓存取不到的数据，在数据库中也没有取到，可以将key-value写为key-null，缓存有效时间可以设置短点，30秒，可以防止攻击用户反复用同一个id暴力攻击  
3. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，避免了对底层存储系统的查询压力  

ps：  
空间的利用到达一种极致，就是bitmap和布隆过滤器  
bitmap———哈希表，缺点是每个元素只能记录1bit信息  
布隆过滤器——引入k个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。  
优点是空间效率和查询时间都超过一般算法，缺点是有一定的误识别率和删除困难。  
Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。  
有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。    
Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。  

### 布隆过滤器  
可以非常方便地判断一个给定数据是否存在于海量数据中。  
具体是这样做的：  
把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。  
总结来说就是： 布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。  




- 缓存击穿  
指缓存中没有但数据库中有的数据（缓存时间到期）  
缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。  
解决方案：  
1. 设置热点数据永不过期  
2. 加互斥锁  

- 缓存预热  
指系统上线后，将相关的缓存数据直接加载到缓存系统。这样可以避免在用户请求时，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。  
解决方案：  
1. 直接写个缓存刷新页面，上线时手工操作  
2. 数据量不大时，可以在项目启动时自动进行加载  
3. 定时刷新缓存  

- 缓存降级  
当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，为保证服务还是可用的，系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。  
最终目的时保证核心服务可用。  
在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：  
一般，警告，错误，严重错误。

服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。  
对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。  

- 热点数据和冷数据  
对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。  
对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存  
数据更新前至少读取两次，缓存才有意义。  
缓存热点key：缓存中的一个Key(比如一个促销商品)，在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。  
解决办法：对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询  



#### 如何保证缓存和数据库数据的一致性？  
Cache Aside Pattern（旁路缓存模式）  
写请求：更新 DB，然后直接删除 cache 。    
如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：缓存失效时间变短（不推荐，治标不治本），增加 cache 更新重试机制（常用）  

















